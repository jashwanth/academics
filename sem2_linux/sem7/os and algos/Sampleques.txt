SAMPLE QUESTIONS FOR MIDTERM, FALL 2013This midterm contains 20 multiple-choice questions, all of equal value. For each question, select the best choice.  Solutions are below.  As a rough guide: 0-2 incorrect answers = A; 3-4 incorrect = B; 5-6 incorrect = C; 7-8 incorrect = D; more than 8 incorrect = F.1. The routine RestoreContext (a) always returns 0; (b) always returns the id of the calling thread; (c) returns either 0 or the id of the calling thread; (d) does not return.2. To yield to another process, a process must (a) save the program counter last; (b) save the stack pointer before the program counter; (c) call SaveContext; (d) call RestoreContext.3. Synchronization is used (a) to avoid deadlocks; (b) to avoid race conditions; (c) to set an alarm; (d) to transfer data from one process to another.4. A critical section (a) must execute before all non-critical sections; (b) must execute before another process executes; (c) can be executed by multiple processes only on a multiprocessor; (d) can only be executed by one process at a time.5. One necessary condition satisfying mutual exclusion is (a) no process outside its critical section may block other processes; (b) a process inside its critical section causes all other processes to block; (c) a process may cause another process in its critical section to block; (d) no process inside its critical section may block other processes.6. The semaphore Signal operation increments the semaphore's value (a) only if there are no waiting processes; (b) and if there are no waiting processes, puts the process to sleep; (c) and if there are any waiting processes, wakes one of them up; (d) only if there are waiting processes.7. Any interprocess communication (IPC) mechanism (a) cannot be implemented solely with semaphores and shared memory; (b) requires mechanisms for data transfer or synchronization, but not necessarily both; (c) requires mechanisms for data transfer and synchronization; (d) may be implemented solely with semaphores.8. In a monitor, mutual exclusion is achieved by (a) allowing only one process to be active inside the monitor; (b) forcing a process to leave immediately if another is trying to enter; (c) allowing processes to wait and signal other processes; (d) forcing a process to wait if another is trying to enter.9. Synchronization is achieved in message passing by (a) not allowing a process to call receive until another process has called send; (b) allowing a process to call receive only after another process has called send; (c) making a process that calls receive to wait until the message is sent; (d) making a sending process check whether another process is waiting to receive a message.10. When evaluated based on turnaround time, shortest process next (a) is always better than first-come-first-served; (b) is never worse than shortest-remaining-time-first; (c) may be better or worse than first-come-first-served; (d) may be better or worse than round-robin.11. If processes are executed in shortest-to-longest order, what is minimized: (a) average time spent using the CPU; (b) total time before all complete; (c) average time spent waiting for the CPU; (d) total time the CPU is idle.12. Which is a condition for mutual exclusion: (a) semaphores must be used to guard critical sections; (b) Receive must be called before Send when using message passing; (c) a process outside a critical section cannot cause a process about to enter a critical section to block; (d) Signal must be the last statement in a monitor procedure.13. When a process calls Wait(sem), which of the following cannot happen: (a) a blocked process becomes ready; (b) the calling process blocks; (c) a deadlock occurs; (d) the calling process does not block.14. In the Banker's algorithm, a safe state means (a) deadlock can definitely be avoided; (b) there are no guarantees that deadlock can be avoided; (c) one or more resources are available; (d) all resources are currently being used.15. Peterson's algorithm (a) can't be used for mutual exclusion; (b) can be used for mutual exclusion, but requires busy waiting; (c) can be used for mutual exclusion and avoids busy waiting; (d) is more efficient than using test-and-set.16. Monitors require programming language (compiler) support to implement (a) producer/consumer; (b) mutual exclusion; (c) context switching; (d) deadlock prevention.17. To support timesharing, the following must be supported by the kernel: (a) the Yield system call; (b) preemption; (c) first-come-first-served scheduling; (d) semaphores.18. To implement user-level threads, (a) the process stack must contain a stack per thread; (b) context switching between threads must be supported by the kernel; (c) thread scheduling is done by the kernel; (d) all of the above.

19. In PA2, DoSched() is used to (a) cause the kernel to make a scheduling decision at the next opportune time; (b) determine which process should run next; (c) cause a context switch; (d) respond to a timer interrupt.20. In PA2, a call to RequestCPUrate(m,n) may be denied if (a) m < n; (b) m > n; (c) m = n; (d) all of the above.

Solutions1. The routine RestoreContext (a) always returns 0; (b) always returns the id of the calling thread; (c) returns either 0 or the id of the calling thread; (d) does not return.(d) RestoreContext restores the value of the PC to a saved value. Once the PC is loaded, a jump occurs to whatever location was saved, which has no relationship to how RestoreContext was called. Returning makes no sense for RestoreContext.2. To yield (give up the CPU) to another process, a process must (a) save the program counter last; (b) save the stack pointer before the program counter; (c) call SaveContext; (d) call RestoreContext.(d) It is RestoreContext that actually causes control to transfer to another process.  The other answers may be part of a yield operation, but the MOST IMPORTANT part is RestoreContext.  In fact, if a process did not care whether it was ever resumed (such as if it were to exit), yield would ONLY do a RestoreContext.  RestoreContext is the only operation that MUST be done to transfer control.3. Synchronization is used (a) to avoid deadlocks; (b) to avoid race conditions; (c) to set an alarm; (d) to transfer data from one process to another.(b) The only way to avoid race conditions is to have one process wait for another, which is synchronization, so that they are not in critical sections at the same time.4. A critical section (a) must execute before all non-critical sections; (b) must execute before another process executes; (c) can be executed by multiple processes only on a multiprocessor; (d) can only be executed by one process at a time.(d) A critical section identifies a region of code where indeterminate results can result if its execution by multiple processes is not serialized (executed by one after another).  Having it executed by one process at a time ensures mutual exclusion.5. One necessary condition satisfying mutual exclusion is (a) no process outside its critical section may block other processes; (b) a process inside its critical section causes all other processes to block; (c) a process may cause another process in its critical section to block; (d) no process inside its critical section may block other processes.(a) This is one of the four conditions for mutual exclusion.  The others are not.6. The semaphore Signal operation increments the semaphore's value (a) only if there are no waiting processes; (b) and if there are no waiting processes, puts the process to sleep; (c) and if there are any waiting processes, wakes one of them up; (d) only if there are waiting processes.(c) This is straight from the code given in the notes for semaphores.7. Any interprocess communication (IPC) mechanism (a) cannot be implemented solely with semaphores and shared memory; (b) requires mechanisms for data transfer or synchronization, but not necessarily both; (c) requires mechanisms for data transfer and synchronization; (d) may be implemented solely with semaphores.(c) Again, straight from the notes: interprocess communication mechanism requires mechanisms for data transfer and synchronization.8. In a monitor, mutual exclusion is achieved by (a) allowing only one process to be active inside the monitor; (b) forcing a process to leave immediately if another is trying to enter; (c) allowing processes to wait and signal other processes; (d) forcing a process to wait if another is trying to enter.(a) Mutual exclusion means only one process active (running or able to run) at the exclusion of all others.9. Synchronization is achieved in message passing by (a) not allowing a process to call receive until another process has called send; (b) allowing a process to call receive only after another process has called send; (c) making a process that calls receive to wait until the message is sent; (d) making a sending process check whether another process is waiting to receive a message.(c) Synchronization (arranging for events to occur at the same time) is effected by having one process wait for another.  Since a process cannot receive a message that was not yet sent, it must wait, and only the operating system can have it wait until the message is sent.10. When evaluated based on turnaround time, shortest process next (a) is always better than first-come-first-served; (b) is never worse than shortest-remaining-time-first; (c) may be better or worse than first-come-first-served; (d) may be better or worse than round-robin.(d) Shortest process first (SPF) is the best possible non-preemptive scheduling algorithm.  FCFS is also non-preemptive, but if all processs arrive in order of shortest to longest, FCFS will do just as well as SPF, so (a) is incorrect (since it says SPF is ALWAYS better). However, SPF can never do worse than FCFS, so (c) is incorrect. Shortest-remaining-time-first is the best possible preemptive scheduling algorithm, and so SPF, which is non-preemtive, may in fact do worse, so (b) is incorrect.  Since round-robin is preemptive and can therefore adapt to new arrivals better than SPF, it may do better; or, it may do worse, making (d) the correct answer.11. If processes are executed in shortest-to-longest order, what is minimized: (a) average time spent using the CPU; (b) total time before all complete; (c) average time spent waiting for the CPU; (d) total time the CPU is idle.(c) Shortest-to-longest minimizes average turnaround time, where turnaround time is completion or departure time - arrival time, part of which is time using the CPU and part is waiting.  Since the time using the CPU cannot be changed, it must be the waiting time that is being reduced.12. Which is a condition for mutual exclusion: (a) semaphores must be used to guard critical sections; (b) Receive must be called before Send when using message passing; (c) a process outside a critical section cannot cause a process about to enter a critical section to block; (d) Signal must be the last statement in a monitor procedure.(c) This is right out of the lecture notes or book.  The other statements are relevant to synchronization, but only (c) is a condition for mutual exclusion.13. When a process calls Wait(sem), which of the following cannot happen: (a) a blocked process becomes ready; (b) the calling process blocks; (c) a deadlock occurs; (d) the calling process does not block.(a) Calling wait cannot possibly wake up a blocked process.  Calling wait CAN possibly cause the calling process to block (if sem = 0), CAN possibly cause a deadlock (c) (if sem = 0 and Signal(sem) is never called), or CAN possibly cause the calling process to not block (if sem > 0).14. In the Banker's algorithm, a safe state means (a) deadlock can definitely be avoided; (b) there are no guarantees that deadlock can be avoided; (c) one or more resources are available; (d) all resources are currently being used.(a) This is the definition of a safe state, and none of the other choices make sense.15. Peterson's algorithm (a) can't be used for mutual exclusion; (b) can be used for mutual exclusion, but requires busy waiting; (c) can be used for mutual exclusion and avoids busy waiting; (d) is more efficient than using test-and-set.(b) Peterson's algorithm is a software solution to mutual exclusion, and explicitly uses busy waiting to test its state variables.16. Monitors require programming language (compiler) support to implement (a) producer/consumer; (b) mutual exclusion; (c) context switching; (d) deadlock prevention.(b) Calling a monitor procedure causes the monitor lock to be obtained, the point of which is to support mutual exclusion.  This occurs automatically by simply calling the procedure, and therefore it must be the compiler that generates the instructions because only the compiler recognizes the monitor programming language construct.17. To support timesharing, the following must be supported by the kernel: (a) the Yield system call; (b) preemption; (c) first-come-first-served scheduling; (d) semaphores.(b) Timesharing means that each process repeatedly gets a slice of time, or quantum.  At the end of the quantum, it's time for another process to get a turn, which means the CPU needs to be taken away from the current process.  This is what preemption is, forcibly taking away a resource.18. To implement user-level threads, (a) the process stack must contain a stack per thread; (b) context switching between threads must be supported by the kernel; (c) thread scheduling is done by the kernel; (d) all of the above.(a) Each thread needs its own stack to maintain activation records of its pending procedure calls.  These stacks must be somewhere.  Since these are user-level threads, the kernel doesn't know anything about them, and so (b) and (c) cannot be true, and the stacks must be in the process's memory.19. In PA2, DoSched is used to (a) cause the kernel to make a scheduling decision at the next opportune time; (b) determine which process should run next; (c) cause a context switch; (d) respond to a timer interrupt.(a) DoSched will cause the kernel to make a scheduling decision at the next opportune time, at which point SchedProc will be called to determine which process to select.


20. In PA2, a call to RequestCPUrate(m,n) may be denied if (a) m < n; (b) m > n; (c) m = n; (d) all of the above.

(d) all of the above.  It should definitely fail for m > n (you can't have a process run for m out of n quantums if m > n).  And while m < n and m = n are potentially valid requests (as long as m > 0), if allowing such a request causes the CPU to be over-allocated, the call will fail.