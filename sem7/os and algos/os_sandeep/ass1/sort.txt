}
}
}
}
}
}
}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
		}
		}
		}
		}
		}
		}
		}
		}
		}
		}
		}
		}
		}
		}
		}
		}
		}
		}
		}
		}
		}
		}
		}
		}
		}
		}
			}
			}
			}
			}
			}
			}
			}
			}
				}
				}
				}
				}
					}
						}
						}
				arg[i]=(char*)malloc((strlen(prev)+1)*sizeof(char));
		arg[i]=(char*)malloc((strlen(prev)+1)*sizeof(char));
					arg[i]=(char*)realloc(arg[i],(strlen(home)+1)*sizeof(char));
			arg[i]=(char*)realloc(arg[i],strlen(home)*sizeof(char));
	arg[i]=NULL;
			arg[l]=NULL;
	arg[l]=NULL;
		args=0;
	args=i;
	args=l;
			array=(int**)malloc((pipes)*sizeof(int*));
		back_ground=0;
					back_ground=1;
			back_ground=1;
				break;
				break;
			cd(arg);
			char *arg[20];
		char *arg[20];
	char cmd[1000],*pch;
	char dummy[50][100],*ind,*outd,*pip,*sta,try[200];
char **hist_cmd;
char *home;
	char host[1000];
char indirec_file[100],outdirec_file[100];
	char *pch;
	char prev[100]="",*temp,*loc;
	char *pwd;
char store[1000][150],process_cmd[1000][50];
	char *user=getenv("USER");
		chdir(home);
		cmd[0]='\0';
			cur++;
				dummy[k][0]='\0';
				dummy[k][0]='\0';
				dummy[k][0]='\0';
				dummy[k][a]='\0';
				dummy[k][b]='\0';
				dummy[k][c]='\0';
				dup2(array[0][1],1);
					dup2(array[j][0],0);
						dup2(array[j+1][1],1);
	}else{
	}else{
	}else{
	}else{
		}else{
		}else{
		}else{
		}else{
		}else{
			}else{
					}else{
		else{
		else{
	}else if ((arg[0][0]=='!')){
	}else if ((arg[0][0]=='h')){
	}else if (args==2){
	}else if (args==2 && strcmp(arg[1],"all")==0){
	}else if (args==2 && strcmp(arg[1],"current")==0){
			}else if (b<c && b<a){
			}else if (c<a && c<b){
		else if (j==outdirec && outdirec>=0){
		}else if (pid==0){
	else if (pid1==0){
		else if (pipes>0 && pipe_mark[cur]==j){
				execute(arg,0);
			execute(arg,0);
					execute(arg,pipe_mark[j]+1);
		_exit(1);
					exit(1);
				exit(1);
		f1=open(outdirec_file, O_WRONLY | O_TRUNC | O_CREAT, S_IRUSR | S_IRGRP | S_IWGRP | S_IWUSR);
		f2=open(indirec_file,O_RDONLY);
			for (i=0;i<hist_count-1;i++) printf(" %d. %s\n",i+1,hist_cmd[i]);
			for (i=0;i<hist_count-1;i++) printf("%d. %s\n",i+1,hist_cmd[i]);
			for (i=0;i<num;i++) printf(" %d. %s\n",i+1,hist_cmd[hist_count-num-1+i]);
		for (i=0;i<process_count-1;i++){
		for (i=0;i<process_count-1;i++){
		for (i=0;i<process_count;i++){
			for (j=0;j<2*pipes;j++) wait(&sigo);
	for (j=0;j<k;j++){
			for (j=0;j<pipes;j++){
			for (j=0;j<pipes;j++) array[j]=(int*)malloc(2*sizeof(int));
				for (j=0;j<pipes;j++) close(array[j][0]),close(array[j][1]);
			for (j=0;j<pipes;j++) close(array[j][0]),close(array[j][1]);
			for (j=0;j<pipes;j++) free(array[j]);
			for (j=0;j<pipes;j++) pipe(array[j]);
	for (j=0,k=0;j<i;j++){
					for (k=0;k<pipes;k++) close(array[k][0]),close(array[k][1]);
				fprintf(stderr,"command not found\n");
			fprintf(stderr,"command not found\n");
			fprintf(stderr,"command not found\n");
			fprintf(stderr,"history has only %d commands\n",hist_count-1);
			fprintf(stderr,"hist requires no arguments\n");
			fprintf(stderr,"hist requires no arguments\n");
			fprintf(stderr,"hist requires no arguments\n");
		fprintf(stderr,"pid takes exactly 1 or no argument or the argument is invalid\n");
			fprintf(stderr,"some error occurred\n");
		fprintf(stderr,"some error occurred\n");
			free(array);
		getchar();
	gethostname(host,1000);
		hist_cmd=(char**)realloc(hist_cmd,(hist_count+1)*sizeof(char*));
		hist_cmd[hist_count]=(char*)malloc(strlen(arg[0])*sizeof(char));
		hist_count++;
			history(arg);
	home=getenv("PWD");
				i++;
		i++;
			if (a<b && a<c){
		if (args==1){
		if (args==1){
		if (args==1){
	if (args==1){
	if (args==1){
		if (args==1 && strcmp(arg[0],"quit")==0) break;
		if (back_ground!=1){
			if (ch==0){
		if (f1!=1) dup2(f1,1);
		if (f2!=0) dup2(f2,0);
				if (fork()==0){
	if (indirec>=0 && in_yes){
						if (indirec<=args && indirec!=1) in_yes=1;
				if (indirec<=pipe_mark[0]) in_yes=1;
						if (indirec<=pipe_mark[j+1] && indirec!=-1) in_yes=1;
			if (ind!=NULL) a=ind-sta;
			if (ind==NULL && outd==NULL && pip==NULL){
		if (j==indirec && indirec>=0){
					if (j!=pipes-1){
			if (l>=i) arg[l]=(char*)malloc((strlen(dummy[j])+1)*sizeof(char));
			if (l>i) arg[l]=(char*)malloc((strlen(dummy[j])+1)*sizeof(char));
			if (loc-prev+1==j){
		if (num>hist_count-1){
		if (num>hist_count-1){
	if (outdirec>=0 && out_yes){
						if (outdirec<=args && outdirec!=-1){
				if (outdirec<=pipe_mark[0]) out_yes=1;
						if (outdirec<=pipe_mark[j+1] && outdirec!=-1){
			if (outd!=NULL)	b=outd-sta;
		if (p==1){
		if (pch!=NULL){
		if (pid<0){
	if (pid!=-1){
	if (pid1<0){
		if (pipes==0) execute(arg,0);
			if (pip!=NULL) c=pip-sta;
				if (prev[strlen(prev)-1]=='&' && strlen(prev)>1){
		if (prev[strlen(prev)-1]=='&' && strlen(prev)>1){
			if (process[i]==pid){
			if (re<0){
		if (re<0) fprintf(stderr,"command not found\n");
		if (ret!=0) printf("No such file or directory %s\n",arg[1]);
		if (sscanf(arg[0],"!hist%d",&num)==0){
		if (sscanf(arg[0],"hist%d",&num)==0){
	if ((strcmp(arg[0],"hist")==0)){
	if (strcmp(arg[i-1],"&")==0) back_ground=1,arg[i-1]=NULL,i--;
		if (strcmp(arg[start],"cd")==0){
		if (strcmp(arg[start],"pid")==0){
				if (strcmp(prev,"~")==0){
		if (strcmp(prev,"~")==0){
		if (strlen(cmd)==0) continue;
				if (strlen(dummy[k])>0){
				if (strlen(dummy[k])>0) k++;
				if (strlen(dummy[k])>0) k++;
			if (strlen(prev)>0){
	if (strlen(prev)!=0){
		if (strstr(arg[start],"hist")!=NULL){
			if (working[i]==1) printf("command name: %s process id: %d\n",process_cmd[i],process[i]);
		inc++;
	inc=0;
#include<dirent.h>
#include<errno.h>
#include<fcntl.h>
#include<signal.h>
#include<stdio.h> 
#include<stdlib.h>
#include<string.h>
#include<sys/ptrace.h>
#include<sys/stat.h>
#include<sys/types.h>
#include<sys/wait.h>
#include<unistd.h>
		indirec_file[0]='\0';
				indirec=k;
			indirec=l;
		indirec=outdirec=-1;
			ind=outd=pip=NULL;
			ind=strchr(sta,'<');
			int a=100,b=100,c=100;
int args,hist_count,process_count,process[1000],working[1000],original_pid,back_ground,inc,pipes,pipe_mark[20],indirec,outdirec;
int **array,in_yes,out_yes,prev_read,curr_write;
			int ch=fork();
	int f1=1,f2=0;
int global;
		int i;
	int i;
	int i;
	int i=0,j,k;
			int j;
					int k;
	int l=0,cur=0;
int main(){
		int num;
		int num;
		int p=1;
			int re=execvp(arg[0],arg);
		int re=execvp(arg[start],&arg[start]);
		int ret=chdir(arg[1]);
			int sigo;
	int status;
	int status;
				in_yes=0;
			in_yes=0;
		in_yes=1;
			j=strlen(prev);
		j=strlen(prev);
					k++;
				k++;
		k=0;
				k=prev-loc+1;
			l++;
			l++;
			l++;
		loc=strchr(prev,'\\');
			loc=strchr(prev+k,'\\');
		memset(pipe_mark,0,sizeof(pipe_mark));
	memset(working,0,sizeof(working));
	original_pid=getpid();
		outdirec_file[0]='\0';
				outdirec=k;
			outdirec=l;
			outd=strchr(sta,'>');
				out_yes=0;
			out_yes=0;
							out_yes=1;
							out_yes=1;
		out_yes=1;
				p=0;
		parse(arg,cmd);
			parse(arg,store[num-1]);
		pch=strstr(pwd,home);
	pch=strtok(cmd," \t");
		pch=strtok(NULL," \t");
			pid(arg);
	pid_t pid;
	pid_t pid1=fork();
		pid_t pid=fork();
	pid=waitpid(WAIT_ANY,&status,WNOHANG);
			pipe_mark[cur]=l;
				pipe_mark[pipes]=k;
				pipes++;
		pipes=0;
			pip=strchr(sta,'|');
				prev[0]='\0';
				prev[j]='\0';
				prev[j-1]=' ';
				prev[loc-prev]='\0';
					prev[strlen(prev)-1]='\0';
			prev[strlen(prev)-1]='\0';
		printf("cd takes 2 arguments, %d arguments given\n",args-1);
		printf("command name: ./a.out process id: %d\n",getpid());
			printf("command name: %s process id: %d\n",process_cmd[i],process[i]);
			printf("command %s pid:%d\n",arg[start],pid1);
//		printf("guy_yes\n");
	printf("HELLO\n");
		printf("List of all processes spawned from this shell:\n");
		printf("List of currently executing processes spawned from this shell:\n");
//		printf("lop_yes %d\n",start);
				printf("\n%s %d exited normally\n",process_cmd[i],process[i]);
		printf("<%s@%s:%s>",user,host,pwd);
			process_count++;
			process_count++;
			process_count++;
		process_count++;
		process_count++;
		process_count++;
	process_count++;
	process_count++;
		process[process_count]=getpid();
		process[process_count]=getpid();
		process[process_count]=getpid();
	process[process_count]=getpid();
	process[process_count]=getpid();
			process[process_count]=pid;
			process[process_count]=pid1;
			process[process_count]=pid1;
		pwd=getcwd(NULL,1000);
			pwd=pwd+strlen(home)-1;
			pwd[strlen(home)-1]='~';
			return;
			return;
			return;
			return;
			return;
			return;
			return;
			return;
		return;
		return;
		return;
		return;
	return 0;
		scanf("%[^\n]",cmd);
	signal(SIGABRT,SIG_IGN);
	signal(SIGCHLD,sigchild_handler);
//	signal(SIGINT,SIG_IGN);
	signal(SIGQUIT,SIG_IGN);
	signal(SIGTSTP,SIG_IGN);
			sleep(0);
			sleep(0.5);
			sleep(0.5);
				sta=sta+a+1;
				sta=sta+b+1;
				sta=sta+c+1;
		sta=try;
		strcat(prev,pch);
				strcat(prev,temp);
				strcpy(arg[i],prev);
		strcpy(arg[i],prev);
			strcpy(arg[l],dummy[j]);
			strcpy(arg[l],dummy[j]);
				strcpy(dummy[k],sta);
		strcpy(hist_cmd[hist_count],arg[0]);
			strcpy(indirec_file,dummy[j]);
			strcpy(outdirec_file,dummy[j]);
		strcpy(prev,"");
					strcpy(prev,home);
			strcpy(prev,home);
			strcpy(process_cmd[process_count],arg[0]);
		strcpy(process_cmd[process_count],arg[0]);
		strcpy(process_cmd[process_count],arg[0]);
		strcpy(process_cmd[process_count],arg[0]);
	strcpy(process_cmd[process_count],arg[0]);
	strcpy(process_cmd[process_count],arg[0]);
			strcpy(process_cmd[process_count],arg[start]);
			strcpy(process_cmd[process_count],arg[start]);
		strcpy(store[inc],cmd);
		strcpy(try,arg[j]);
				strncpy(dummy[k],sta,a);
				strncpy(dummy[k],sta,b);
				strncpy(dummy[k],sta,c);
				temp=loc+1;
void cd(char **arg);
void cd(char **arg){
void execute(char **arg,int start);
void execute(char **arg,int start){
void history(char **arg);
void history(char **arg){
void parse(char **arg,char *cmd);
void parse(char **arg,char *cmd){
void pid(char **arg);
void pid(char **arg){
void sigchild_handler(int sig);
void sigchild_handler(int sig){
			waitpid(pid1,&status,0);
			waitpid(pid,&i,0);
	while (1){
		while (loc!=NULL){
	while (pch!=NULL){
		while (strlen(sta)>0){
				working[i]=0;
			working[process_count]=1;
